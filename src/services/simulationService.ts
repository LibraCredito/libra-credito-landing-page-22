/**
 * Servi√ßo de simula√ß√£o integrado com Supabase
 * 
 * @service simulationService
 * @description Servi√ßo que combina a API de simula√ß√£o existente com o armazenamento no Supabase
 * 
 * @features
 * - Integra√ß√£o com API de simula√ß√£o existente
 * - Armazenamento autom√°tico no Supabase
 * - Tracking de jornada do usu√°rio
 * - Valida√ß√£o de dados
 * - Tratamento de erros
 * 
 * @workflow
 * 1. Recebe dados da simula√ß√£o
 * 2. Chama API de simula√ß√£o existente
 * 3. Processa resultado
 * 4. Salva no Supabase com session_id
 * 5. Retorna dados para o componente
 */

import { supabaseApi, supabase, SimulacaoData } from '@/lib/supabase';
import { simulateCredit } from '@/services/simulationApi';
import { validateEmail, validatePhone, formatPhone } from '@/utils/validations';
import { PloomesService } from '@/services/ploomesService';
import { WebhookService } from '@/services/webhookService';

// Tipos para o servi√ßo
export interface SimulationInput {
  sessionId: string;
  nomeCompleto: string;
  email: string;
  telefone: string;
  cidade: string;
  valorEmprestimo: number;
  valorImovel: number;
  parcelas: number;
  tipoAmortizacao: string;
  userAgent?: string;
  ipAddress?: string;
}

export interface SimulationResult {
  id: string;
  valor: number;
  amortizacao: string;
  parcelas: number;
  primeiraParcela?: number;
  ultimaParcela?: number;
  valorEmprestimo: number;
  valorImovel: number;
  cidade: string;
  sessionId: string;
}

export interface ContactFormInput {
  simulationId: string;
  sessionId: string;
  nomeCompleto: string;
  email: string;
  telefone: string;
  imovelProprio: 'proprio' | 'terceiro';
  observacoes?: string;
}

// Classe principal do servi√ßo
export class SimulationService {
  
  /**
   * Realiza simula√ß√£o e salva no Supabase
   */
  static async performSimulation(input: SimulationInput): Promise<SimulationResult> {
    try {
      if (!supabase) {
        throw new Error('SERVICO_INDISPONIVEL: Supabase n√£o configurado');
      }

      console.log('üéØ Iniciando simula√ß√£o:', input);
      
      // 1. Validar dados de entrada
      this.validateSimulationInput(input);
      
      // 2. Preparar payload para API existente
      const apiPayload = {
        valor_solicitado: input.valorEmprestimo,
        vlr_imovel: input.valorImovel,
        numero_parcelas: input.parcelas,
        amortizacao: input.tipoAmortizacao,
        juros: 1.09,
        carencia: 2,
        cidade: input.cidade
      };
      
      console.log('üì° Enviando para API:', apiPayload);
      
      // 3. Chamar API de simula√ß√£o existente
      const apiResult = await simulateCredit(apiPayload);
      
      console.log('‚úÖ Resposta da API:', apiResult);
      
      // 4. Processar resultado da API
      const processedResult = this.processApiResult(apiResult, input.tipoAmortizacao, input.parcelas);
      
      // 5. Preparar dados para Supabase
      const supabaseData: Omit<SimulacaoData, 'id' | 'created_at'> = {
        session_id: input.sessionId,
        nome_completo: input.nomeCompleto,
        email: input.email,
        telefone: this.formatPhoneNumber(input.telefone),
        cidade: input.cidade,
        valor_emprestimo: input.valorEmprestimo,
        valor_imovel: input.valorImovel,
        parcelas: input.parcelas,
        tipo_amortizacao: input.tipoAmortizacao,
        parcela_inicial: processedResult.primeiraParcela,
        parcela_final: processedResult.ultimaParcela || processedResult.valor,
        ip_address: input.ipAddress,
        user_agent: input.userAgent,
        status: 'novo'
      };
      
      console.log('üíæ Salvando no Supabase:', supabaseData);

      // 6. Salvar no Supabase
      const savedSimulation = await supabaseApi.createSimulacao(supabaseData);
      
      console.log('‚úÖ Simula√ß√£o salva:', savedSimulation);
      
      // 7. Retornar resultado formatado
      return {
        id: savedSimulation.id!,
        valor: processedResult.valor,
        amortizacao: input.tipoAmortizacao,
        parcelas: input.parcelas,
        primeiraParcela: processedResult.primeiraParcela,
        ultimaParcela: processedResult.ultimaParcela,
        valorEmprestimo: input.valorEmprestimo,
        valorImovel: input.valorImovel,
        cidade: input.cidade,
        sessionId: input.sessionId
      };
      
    } catch (error) {
      console.error('‚ùå Erro na simula√ß√£o:', error);
      throw error;
    }
  }
  
  /**
   * Processa formul√°rio de contato p√≥s-simula√ß√£o
   */
  static async submitContactForm(input: ContactFormInput): Promise<void> {
    try {
      console.log('üìã Processando formul√°rio de contato:', input);
      
      // Importar o cliente Supabase
      const { supabase } = await import('@/lib/supabase');
      
      // Atualizar dados pessoais da simula√ß√£o
      const { data: updatedSimulation, error: updateError } = await supabase
        .from('simulacoes')
        .update({
          nome_completo: input.nomeCompleto,
          email: input.email,
          telefone: this.formatPhoneNumber(input.telefone),
          imovel_proprio: input.imovelProprio,
          status: 'interessado'
        })
        .eq('id', input.simulationId)
        .select()
        .single();
      
      if (updateError) {
        console.error('Erro na atualiza√ß√£o:', updateError);
        throw updateError;
      }
      
      console.log('‚úÖ Dados pessoais atualizados na simula√ß√£o:', updatedSimulation);
      
      // Integra√ß√£o com Ploomes CRM
      try {
        console.log('üîó Integrando com Ploomes CRM...');
        
        // Buscar dados completos da simula√ß√£o para ter o valor da parcela
        const { data: simulacaoCompleta } = await supabase
          .from('simulacoes')
          .select('*')
          .eq('id', input.simulationId)
          .single();
        
        if (!simulacaoCompleta) {
          throw new Error('Simula√ß√£o n√£o encontrada');
        }
        
        // Calcular valor da parcela (usar parcela_inicial para SAC ou parcela_final para PRICE)
        const valorParcela = simulacaoCompleta.tipo_amortizacao === 'SAC' 
          ? simulacaoCompleta.parcela_inicial || simulacaoCompleta.parcela_final || 0
          : simulacaoCompleta.parcela_final || 0;
        
        const ploomesResponse = await PloomesService.cadastrarProposta({
          cidade: simulacaoCompleta.cidade,
          valorEmprestimo: simulacaoCompleta.valor_emprestimo,
          valorImovel: simulacaoCompleta.valor_imovel,
          parcelas: simulacaoCompleta.parcelas,
          tipoAmortizacao: simulacaoCompleta.tipo_amortizacao,
          valorParcela: valorParcela,
          nomeCompleto: input.nomeCompleto,
          email: input.email,
          telefone: input.telefone,
          imovelProprio: input.imovelProprio
        });
        
        if (ploomesResponse.status) {
          console.log('‚úÖ Proposta cadastrada no Ploomes com sucesso');
          
          // Atualizar status para 'integrado_crm' se desejar
          await supabase
            .from('simulacoes')
            .update({ status: 'integrado_crm' })
            .eq('id', input.simulationId);
            
        } else if (PloomesService.isDuplicidadeError(ploomesResponse)) {
          console.warn('‚ö†Ô∏è Lead j√° existe no Ploomes (√∫ltimos 7 dias)');
          // N√£o √© um erro cr√≠tico, apenas um aviso
        } else {
          console.error('‚ùå Erro ao cadastrar no Ploomes:', ploomesResponse.msg);
          // Lan√ßar erro apenas se for cr√≠tico
          // Para duplicidade, apenas logamos
          if (!PloomesService.isDuplicidadeError(ploomesResponse)) {
            // N√£o √© duplicidade, mas n√£o vamos bloquear o fluxo
            console.warn('Erro n√£o cr√≠tico - lead salvo no Supabase');
          }
        }
        
      } catch (ploomesError) {
        console.error('‚ùå Erro na integra√ß√£o com Ploomes:', ploomesError);
        
        // Verificar se √© erro de duplicidade para propagar mensagem espec√≠fica
        if (ploomesError instanceof Error && 
            ploomesError.message.includes('j√° existe') && 
            ploomesError.message.includes('7 dias')) {
          // Propagar erro de duplicidade para mostrar mensagem amig√°vel
          throw new Error('Lead j√° existe no CRM (√∫ltimos 7 dias)');
        }
        
        // Para outros erros, n√£o propagar - o lead j√° foi salvo no Supabase
        console.warn('Erro n√£o cr√≠tico na integra√ß√£o - lead salvo localmente');
      }
      
      // Enviar dados para webhook ap√≥s processamento completo
      try {
        console.log('ü™ù Enviando dados para webhook...');
        
        const webhookPayload = {
          simulationId: input.simulationId,
          sessionId: input.sessionId,
          nomeCompleto: input.nomeCompleto,
          email: input.email,
          telefone: input.telefone,
          cidade: updatedSimulation.cidade,
          imovelProprio: input.imovelProprio,
          observacoes: input.observacoes,
          valorEmprestimo: updatedSimulation.valor_emprestimo,
          valorImovel: updatedSimulation.valor_imovel,
          parcelas: updatedSimulation.parcelas,
          tipoAmortizacao: updatedSimulation.tipo_amortizacao,
          valorParcela: valorParcela,
          primeiraParcela: updatedSimulation.parcela_inicial,
          ultimaParcela: updatedSimulation.parcela_final,
          status: updatedSimulation.status
        };
        
        const webhookCalls = [
          WebhookService.sendSimulationData(webhookPayload)
        ];

        const secondaryUrl = process.env.VITE_WEBHOOK_SECONDARY_URL;
        if (secondaryUrl) {
          webhookCalls.push(
            WebhookService.sendSimulationData(webhookPayload, { url: secondaryUrl })
          );
        }

        const [primaryResult, secondaryResult] = await Promise.all(webhookCalls);

        if (primaryResult.success) {
          console.log('‚úÖ Webhook enviado com sucesso');
        } else {
          console.warn('‚ö†Ô∏è Falha no webhook (n√£o cr√≠tico):', primaryResult.message);
        }

        if (secondaryUrl) {
          if (secondaryResult?.success) {
            console.log('‚úÖ Webhook secund√°rio enviado com sucesso');
          } else {
            console.warn('‚ö†Ô∏è Falha no webhook secund√°rio (n√£o cr√≠tico):', secondaryResult?.message);
          }
        }
        
      } catch (webhookError) {
        console.error('‚ùå Erro no webhook (n√£o cr√≠tico):', webhookError);
        // N√£o propagamos erro do webhook para n√£o afetar o fluxo principal
      }
      
    } catch (error) {
      console.error('‚ùå Erro ao processar contato:', error);
      throw error;
    }
  }
  
  /**
   * Buscar simula√ß√µes para admin
   */
  static async getSimulacoes(limit = 50) {
    try {
      if (!supabase) {
        throw new Error('SERVICO_INDISPONIVEL: Supabase n√£o configurado');
      }
      return await supabaseApi.getSimulacoes(limit);
    } catch (error) {
      console.error('‚ùå Erro ao buscar simula√ß√µes:', error);
      throw error;
    }
  }
  
  /**
   * Atualizar status de simula√ß√£o
   */
  static async updateSimulationStatus(id: string, status: string) {
    try {
      if (!supabase) {
        throw new Error('SERVICO_INDISPONIVEL: Supabase n√£o configurado');
      }
      return await supabaseApi.updateSimulacaoStatus(id, status);
    } catch (error) {
      console.error('‚ùå Erro ao atualizar status:', error);
      throw error;
    }
  }
  
  // M√©todos privados
  
  /**
   * Validar dados de entrada
   */
  private static validateSimulationInput(input: SimulationInput): void {
    if (!input.sessionId) throw new Error('Session ID √© obrigat√≥rio');
    if (!input.nomeCompleto || input.nomeCompleto.length < 3) {
      throw new Error('Nome completo deve ter pelo menos 3 caracteres');
    }
    if (!input.email || !this.validateEmail(input.email)) {
      throw new Error('Email inv√°lido');
    }
    if (!input.telefone || input.telefone.length < 10) {
      throw new Error('Telefone inv√°lido');
    }
    if (!input.cidade) throw new Error('Cidade √© obrigat√≥ria');
    if (input.valorEmprestimo < 75000 || input.valorEmprestimo > 5000000) {
      throw new Error('Valor do empr√©stimo deve estar entre R$ 75.000 e R$ 5.000.000');
    }
    if (input.valorImovel < input.valorEmprestimo * 2) {
      throw new Error('Valor do im√≥vel deve ser pelo menos 2x o valor do empr√©stimo');
    }
  }
  
  /**
   * Processar resultado da API
   */
  private static processApiResult(apiResult: any, amortizacao: string, parcelas: number) {
    if (!apiResult || !apiResult.parcelas || !Array.isArray(apiResult.parcelas)) {
      throw new Error('API retornou estrutura de dados inv√°lida');
    }
    
    // Buscar parcela com valor v√°lido
    const parcelaComValor = apiResult.parcelas.find((p: any, index: number) => 
      index > 0 && p.parcela_final && p.parcela_final[0] > 0
    );
    
    if (!parcelaComValor) {
      throw new Error('API n√£o retornou parcelas com valores v√°lidos');
    }
    
    const valor = parcelaComValor.parcela_final[0];
    
    let primeiraParcela: number | undefined;
    let ultimaParcela: number | undefined;
    
    if (amortizacao === 'SAC') {
      // Para SAC, buscar primeira e √∫ltima parcela
      const primeiraParcelaObj = apiResult.parcelas.find((p: any, index: number) => 
        index > 0 && p.parcela_final && p.parcela_final[0] > 0
      );
      
      if (primeiraParcelaObj?.parcela_final?.[0]) {
        primeiraParcela = primeiraParcelaObj.parcela_final[0];
      }
      
      const ultimaParcelaObj = apiResult.parcelas.slice().reverse().find((p: any) => 
        p.parcela_final && p.parcela_final[0] > 0
      );
      
      if (ultimaParcelaObj?.parcela_final?.[0]) {
        ultimaParcela = ultimaParcelaObj.parcela_final[0];
      }
    }
    
    return {
      valor,
      primeiraParcela,
      ultimaParcela
    };
  }
  
  /**
   * Validar email
   */
  private static validateEmail(email: string): boolean {
    return validateEmail(email);
  }
  
  /**
   * Formatar n√∫mero de telefone
   */
  private static formatPhoneNumber(phone: string): string {
    return formatPhone(phone);
  }
}

export default SimulationService;
